<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Demo</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }

      #log {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f9f9f9;
        margin-top: 20px;
      }

      #messages {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f1f1f1;
        margin-top: 20px;
      }

      .hidden {
        display: none;
      }

      .log-entry {
        margin-bottom: 10px;
      }

      video {
        width: 300px;
        height: 200px;
        border: 1px solid #ccc;
        background: #000;
      }

      .avatar {
        width: 20px;
        height: 20px;
        background: #8b430b;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        font-weight: bold;
        text-transform: uppercase;
        position: absolute;
        bottom: 0;
        left: 0;
        border-radius: 9999px;
      }

      .video-wrapper {
        position: relative;
        display: inline-block;
      }

      #controls button {
        margin: 5px;
      }

      #message-input {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }

      #message-input input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
      }

      #message-input button {
        padding: 5px 10px;
      }
    </style>
  </head>

  <body>
    <h1>WebRTC Demo with Socket.io</h1>
    <div id="username-section">
      <label for="username">Enter your username:</label>
      <input type="text" id="username" />

      <label for="room-type">Choose Room Type:</label>
      <select id="room-type">
        <option value="friend-zone">Friend Zone</option>
        <option value="propagation">Propagation</option>
      </select>
      <label for="gender">Choose Your Gender:</label>
      <select id="gender">
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>

      <button id="start-button">Start</button>
      <div id="base-url" style="visibility: hidden"><%= LIVE_SERVER_URL %></div>
    </div>

    <div id="video-section" class="hidden">
      <h2>Video Call</h2>
      <div style="display: flex; gap: 0.5rem; justify-items: center">
        <div class="video-wrapper">
          <video id="local-video" autoplay muted playsinline></video>
          <div id="local-avatar" class="avatar hidden"></div>
        </div>
        <div class="video-wrapper">
          <video id="remote-video" autoplay playsinline></video>
          <div id="remote-avatar" class="avatar hidden"></div>
        </div>
      </div>
      <div id="controls" class="hidden">
        <button id="toggle-camera">Turn Off Camera</button>
        <button id="toggle-audio">Mute</button>
        <button id="share-screen">Share Screen</button>
        <button id="leave-room">Leave Room</button>
      </div>
      <div id="remote-status" class="hidden">
        <p>remote User:</p>
        <span id="remote-camera-status">Camera: On</span>
        <span id="remote-audio-status">Microphone: Unmuted</span>
      </div>
      <div id="connection-status" style="margin-top: 20px; font-weight: bold">
        Status: <span id="status-text">Waiting for user to join...</span>
      </div>
      <div style="display: flex; gap: 1rem">
        <div id="log" style="flex: 1"></div>
        <div style="flex: 1">
          <h3>Chat</h3>
          <div id="messages"></div>
        </div>
      </div>
      <div id="message-input">
        <input
          type="text"
          id="message-text"
          placeholder="Type your message..."
        />
        <button id="send-message">Send</button>
      </div>
    </div>

    <script>
      const LIVE_SERVER_URL = document.getElementById("base-url").innerText;
      const usernameInput = document.getElementById("username");
      const roomTypeInput = document.getElementById("room-type");
      const genderInput = document.getElementById("gender");
      const startButton = document.getElementById("start-button");
      const usernameSection = document.getElementById("username-section");
      const videoSection = document.getElementById("video-section");
      const statusText = document.getElementById("status-text");
      const localVideo = document.getElementById("local-video");
      const remoteVideo = document.getElementById("remote-video");
      const localAvatar = document.getElementById("local-avatar");
      const remoteAvatar = document.getElementById("remote-avatar");
      const logContainer = document.getElementById("log");
      const toggleCameraButton = document.getElementById("toggle-camera");
      const toggleAudioButton = document.getElementById("toggle-audio");
      const messagesContainer = document.getElementById("messages");
      const messageInput = document.getElementById("message-text");
      const sendMessageButton = document.getElementById("send-message");
      const remoteCameraStatus = document.getElementById(
        "remote-camera-status",
      );
      const remoteAudioStatus = document.getElementById("remote-audio-status");
      const shareScreenButton = document.getElementById("share-screen");
      const leaveRoomButton = document.getElementById("leave-room");

      let isScreenSharing = false;
      let screenStream;
      /**
       * @type {MediaStreamConstraints}
       */
      const mediaConstraints = {
        video: {
          width: { ideal: 320 },
          height: { ideal: 240 },
          frameRate: { ideal: 15 },
          facingMode: { ideal: "user" },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
      };
      let socket;
      let peerConnection;
      let localStream;
      let rtcConfig = {};
      let participants = [];
      const user = {
        id: new Date().getTime(),
        gender: "",
        username: "",
        isMobile: true,
        roomType: "",
      };

      // Track if we've already set up the remote video to avoid duplicate setup
      let remoteVideoSetup = false;
      let remoteStream = null;

      // Define STUN and TURN servers for better connectivity
      const iceServers = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          // Add free TURN servers - you should replace these with your own TURN servers for production
          {
            urls: "turn:35.183.200.31:3478",
            credential: "password",
            username: "username",
          },
          {
            urls: "turn:numb.viagenie.ca",
            credential: "muazkh",
            username: "webrtc@live.com",
          },
          {
            urls: "turn:turn.anyfirewall.com:443?transport=tcp",
            credential: "webrtc",
            username: "webrtc",
          },
        ],
        iceCandidatePoolSize: 10,
      };

      // Function to handle screen sharing
      async function toggleScreenShare() {
        if (!isScreenSharing) {
          try {
            // Start screen sharing
            screenStream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
            });

            // Replace the current video track with the screen track
            const screenTrack = screenStream.getVideoTracks()[0];
            const sender = peerConnection
              .getSenders()
              .find((s) => s.track.kind === "video");
            if (sender) sender.replaceTrack(screenTrack);

            // Update the local video element
            localVideo.srcObject = screenStream;

            screenTrack.onended = () => {
              // Automatically stop screen sharing when the user stops sharing
              stopScreenShare();
            };

            isScreenSharing = true;
            shareScreenButton.textContent = "Stop Sharing";
          } catch (error) {
            log("Screen sharing failed: " + error.message);
          }
        } else {
          stopScreenShare();
        }
      }

      // Function to stop screen sharing
      function stopScreenShare() {
        if (screenStream) {
          const screenTrack = screenStream.getVideoTracks()[0];
          if (screenTrack) screenTrack.stop();

          // Revert to the original camera video track
          const videoTrack = localStream.getVideoTracks()[0];
          const sender = peerConnection
            .getSenders()
            .find((s) => s.track.kind === "video");
          if (sender) sender.replaceTrack(videoTrack);

          localVideo.srcObject = localStream;
          isScreenSharing = false;
          shareScreenButton.textContent = "Share Screen";
        }
      }

      // Add an event listener for the "Share Screen" button
      shareScreenButton.addEventListener("click", toggleScreenShare);

      leaveRoomButton.addEventListener("click", () => {
        socket?.emit("room:leave");
        if (peerConnection) peerConnection.close();
        peerConnection = null;
        log("left the room.");
        updateConnectionStatus("Waiting for user to join...");
        setInitials(remoteAvatar, "");
        document.getElementById("remote-status").classList.add("hidden");
        remoteVideo.srcObject = null;
        remoteVideoSetup = false; // Reset the flag
        remoteStream = null;

        // Remove any play buttons
        const playButton = document.querySelector(".manual-play-button");
        if (playButton) playButton.remove();

        rtcConfig = {};
        participants = [];
      });

      function updateConnectionStatus(status) {
        statusText.textContent = status;
      }

      function log(message) {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.textContent = message;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function setInitials(element, name) {
        const initials = name
          .split(" ")
          .map((n) => n[0])
          .join("")
          .toUpperCase();
        element.textContent = initials;
      }

      // Modify the getUserMedia function to ensure proper constraints for mobile
      async function getUserMedia() {
        try {
          log("Accessing local media...");

          // Use very basic constraints for maximum compatibility
          const simpleConstraints = {
            video: true,
            audio: true,
          };

          localStream = await navigator.mediaDevices.getUserMedia(
            simpleConstraints,
          );
          localVideo.srcObject = localStream;

          try {
            await localVideo.play();
            log("Local video playback started");
          } catch (err) {
            log(`Error starting local video playback: ${err.message}`);
          }

          log("Local media stream added.");
        } catch (error) {
          log("Error getting User Media: " + error.message);
        }
      }

      async function initializeWebRTC() {
        try {
          updateConnectionStatus("Connecting to the other user...");
          log("Creating RTCPeerConnection...");

          // Use our predefined ice servers
          peerConnection = new RTCPeerConnection(iceServers);

          peerConnection.onconnectionstatechange = () => {
            log("Connection state changed: " + peerConnection.connectionState);
            if (peerConnection.connectionState === "connected") {
              updateConnectionStatus("Connected");
            } else if (peerConnection.connectionState === "failed") {
              log("Connection failed. Attempting to restart...");
              restartConnection();
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            log(
              "ICE connection state changed: " +
                peerConnection.iceConnectionState,
            );
            if (peerConnection.iceConnectionState === "disconnected") {
              log("ICE Disconnected. Attempting to reconnect...");
              if (peerConnection.restartIce) {
                peerConnection.restartIce();
              }
            } else if (peerConnection.iceConnectionState === "failed") {
              log("ICE Connection failed. Attempting to restart...");
              restartConnection();
            }
          };

          // Add local tracks to the connection
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              log("Adding local track to peer connection: " + track.kind);
              peerConnection.addTrack(track, localStream);
            });
          } else {
            log("No local stream available to add tracks");
          }

          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              log("Sending ICE candidate...");
              socket.emit("rtc:candidate", { candidate: event.candidate });
            }
          };

          // Handle incoming tracks
          peerConnection.ontrack = (event) => {
            log("Track received: " + event.track.kind);

            if (event.streams && event.streams[0]) {
              log(
                "Remote stream received with " +
                  event.streams[0].getTracks().length +
                  " tracks",
              );

              // Store the remote stream
              remoteStream = event.streams[0];

              // Set up the remote video
              setupRemoteVideo(remoteStream);
            } else {
              log("No remote stream available in the track event");
            }
          };

          log("WebRTC initialized with ICE servers.");
        } catch (error) {
          log("Error initializing WebRTC: " + error.message);
          updateConnectionStatus("Error connecting");
        }
      }

      // Function to set up the remote video
      function setupRemoteVideo(stream) {
        if (!remoteVideoSetup && stream) {
          log("Setting up remote video");

          // Set the source
          remoteVideo.srcObject = stream;
          remoteVideoSetup = true;

          // Make sure remote video is visible
          remoteVideo.style.display = "block";
          remoteVideo.style.opacity = "1";

          document.getElementById("remote-status").classList.remove("hidden");

          // Create a play button immediately for mobile devices
          createPlayButton();

          // Try to play the video automatically
          setTimeout(() => {
            playRemoteVideo();
          }, 1000);
        }
      }

      // Function to restart the connection if it fails
      function restartConnection() {
        log("Restarting connection...");

        if (peerConnection) {
          peerConnection.close();
        }

        // Reset flags
        remoteVideoSetup = false;
        remoteStream = null;

        // Remove remote video source
        remoteVideo.srcObject = null;

        // Remove any play buttons
        const playButton = document.querySelector(".manual-play-button");
        if (playButton) playButton.remove();

        // Reinitialize WebRTC
        setTimeout(() => {
          initializeWebRTC();
          // If we were the offerer, create a new offer
          if (socket) {
            socket.emit("connection:restart");
          }
        }, 1000);
      }

      // Function to safely play the remote video
      function playRemoteVideo() {
        if (remoteVideo.paused && remoteVideo.srcObject) {
          log("Attempting to play remote video...");

          // Ensure it's not muted
          remoteVideo.muted = false;

          // Try to play
          const playPromise = remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                log("Remote video is now playing");
              })
              .catch((err) => {
                log("Error playing remote video: " + err.message);
                // Make the play button visible
                const existingButton = document.querySelector(
                  ".manual-play-button",
                );
                if (existingButton) {
                  existingButton.style.display = "block";
                } else {
                  createPlayButton();
                }
              });
          }
        } else {
          log("Remote video is already playing or has no source");
        }
      }

      // Add a button to manually play the video
      function createPlayButton() {
        // Check if button already exists
        if (document.querySelector(".manual-play-button")) return;

        const playButton = document.createElement("button");
        playButton.textContent = "Tap to Play Video";
        playButton.className = "manual-play-button";
        playButton.style.position = "absolute";
        playButton.style.top = "50%";
        playButton.style.left = "50%";
        playButton.style.transform = "translate(-50%, -50%)";
        playButton.style.zIndex = "10";
        playButton.style.padding = "10px 20px";
        playButton.style.backgroundColor = "#4CAF50";
        playButton.style.color = "white";
        playButton.style.border = "none";
        playButton.style.borderRadius = "5px";
        playButton.style.cursor = "pointer";

        playButton.onclick = () => {
          playRemoteVideo();
          playButton.style.display = "none";
        };

        const remoteVideoWrapper =
          document.querySelector("#remote-video").parentElement;
        remoteVideoWrapper.appendChild(playButton);
      }

      function updateStatus() {
        const videoTrack = localStream?.getVideoTracks()[0];
        const audioTrack = localStream?.getAudioTracks()[0];

        const status = {
          cameraOn: videoTrack?.enabled ?? false,
          audioOn: audioTrack?.enabled ?? false,
        };

        socket.emit("status:update", status);
      }

      startButton.addEventListener("click", async () => {
        const username = usernameInput.value.trim();
        const roomType = roomTypeInput.value;
        const gender = genderInput.value;

        if (!username) {
          alert("Username is required!");
          return;
        }
        if (!roomType) {
          alert("roomType is required!");
          return;
        }
        if (!gender) {
          alert("gender is required!");
          return;
        }
        user.username = username;
        user.roomType = roomType;
        user.gender = gender;

        usernameSection.classList.add("hidden");
        videoSection.classList.remove("hidden");
        document.getElementById("controls").classList.remove("hidden");

        setInitials(localAvatar, username);
        await getUserMedia();

        log(`Hello, ${username}! Connecting to server...`);
        updateConnectionStatus("Waiting for user to join...");

        socket = io(LIVE_SERVER_URL, { query: user });

        socket.on("connect", () => {
          log("Connected to the server.");
          socket.emit("room:join", { roomType });
        });

        socket.on("user:left", () => {
          log("remote user left");
          updateConnectionStatus("Waiting for user to join...");
          setInitials(remoteAvatar, "");
          remoteVideo.srcObject = null;
          remoteVideoSetup = false; // Reset the flag
          remoteStream = null;
          document.getElementById("remote-status").classList.add("hidden");

          // Remove any play buttons
          const playButton = document.querySelector(".manual-play-button");
          if (playButton) playButton.remove();
        });

        socket.on("room:start_offerer", async (config) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          log("Creating RTC offer...");
          const offer = await peerConnection.createOffer({
            iceRestart: true,
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          await peerConnection.setLocalDescription(offer);
          socket.emit("rtc:offer", { offer });
          log("RTC offer sent.");
        });

        socket.on("room:start", async (config) => {
          rtcConfig = config;
          await initializeWebRTC();
        });
        socket.on(
          "user:joined",
          ({
            socketId,
            username,
            gender,
            roomId,
            participants: newParticipants,
          }) => {
            participants = newParticipants;
            const remoteUser = participants.find(
              (_user) => _user.id !== user.id,
            );
            if (remoteUser?.username) {
              setInitials(remoteAvatar, remoteUser.username);
            }
          },
        );

        socket.on("rtc:offer", async ({ offer }) => {
          log("Received RTC offer");
          if (!peerConnection) {
            await initializeWebRTC();
          }

          try {
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(offer),
            );
            log("Set remote description from offer");

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            log("Created and set local answer");

            socket.emit("rtc:answer", { answer });
            log("Sent answer to peer");
          } catch (error) {
            log("Error handling offer: " + error.message);
          }
        });

        socket.on("rtc:answer", async ({ answer }) => {
          log("Received RTC answer");
          if (peerConnection) {
            try {
              await peerConnection.setRemoteDescription(
                new RTCSessionDescription(answer),
              );
              log("Set remote description from answer");
            } catch (error) {
              log("Error setting remote description: " + error.message);
            }
          }
        });

        socket.on("rtc:candidate", async ({ candidate }) => {
          log("Received ICE candidate");
          if (peerConnection) {
            try {
              await peerConnection.addIceCandidate(
                new RTCIceCandidate(candidate),
              );
              log("Added ICE candidate");
            } catch (error) {
              log("Error adding ICE candidate: " + error.message);
            }
          }
        });

        socket.on("status:update", ({ userId, roomUsers }) => {
          participants = roomUsers;
          const remoteUser = roomUsers.find((user) => user.id === userId);
          if (!remoteUser) {
            log("Remote User Not Found");
            return;
          }
          log(
            `Camera On: ${remoteUser.cameraOn}, Audio On: ${remoteUser.audioOn}`,
          );
          remoteCameraStatus.textContent = `Camera: ${
            remoteUser.cameraOn ? "On" : "Off"
          }`;

          remoteAudioStatus.textContent = `Microphone: ${
            remoteUser.audioOn ? "Unmuted" : "Muted"
          }`;

          if (!remoteUser.cameraOn) {
            remoteVideo.style.opacity = "0.5";
          } else {
            remoteVideo.style.opacity = "1";
          }

          setInitials(remoteAvatar, remoteUser.username);
        });

        socket.on("message:receive", (messages) => {
          messagesContainer.innerHTML = "";
          messages.forEach((message) => {
            const { username, value } = message;
            appendMessage(username, value);
          });
        });

        socket.on("disconnect", () => {
          log("Disconnected from the server.");
          if (peerConnection) peerConnection.close();
          peerConnection = null;
        });

        // Add a tap event listener to the document to help with autoplay on iOS
        document.addEventListener(
          "touchstart",
          function () {
            if (remoteVideo && remoteVideo.paused && remoteStream) {
              playRemoteVideo();
            }
          },
          { once: true },
        );

        // Add this to handle autoplay restrictions
        document.addEventListener(
          "click",
          function () {
            if (remoteVideo && remoteVideo.paused && remoteVideo.srcObject) {
              playRemoteVideo();
            }
          },
          { once: true },
        );
      });

      function appendMessage(username, message) {
        const messageEntry = document.createElement("div");
        messageEntry.innerHTML = `<strong>${username}:</strong> ${message}`;
        messagesContainer.appendChild(messageEntry);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      toggleCameraButton.addEventListener("click", () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            toggleCameraButton.textContent = videoTrack.enabled
              ? "Turn Off Camera"
              : "Turn On Camera";
          }
        }
        updateStatus();
      });

      toggleAudioButton.addEventListener("click", () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            toggleAudioButton.textContent = audioTrack.enabled
              ? "Mute"
              : "Unmute";
          }
        }
        updateStatus();
      });

      sendMessageButton.addEventListener("click", () => {
        const message = messageInput.value.trim();
        if (message) {
          socket.emit("message:send", { message });
          messageInput.value = "";
        }
      });

      messageInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") sendMessageButton.click();
      });

      // Add a new socket event for connection restart
      socket.on("connection:restart", () => {
        log("Received connection restart request");
        restartConnection();
      });
    </script>
  </body>
</html>
