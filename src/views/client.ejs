<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Demo</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }

      #log {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f9f9f9;
        margin-top: 20px;
      }

      #messages {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f1f1f1;
        margin-top: 20px;
      }

      .hidden {
        display: none;
      }

      .log-entry {
        margin-bottom: 10px;
      }

      video {
        width: 300px;
        height: 200px;
        border: 1px solid #ccc;
        background: #000;
      }

      .avatar {
        width: 20px;
        height: 20px;
        background: #8b430b;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        font-weight: bold;
        text-transform: uppercase;
        position: absolute;
        bottom: 0;
        left: 0;
        border-radius: 9999px;
      }

      .video-wrapper {
        position: relative;
        display: inline-block;
      }

      #controls button {
        margin: 5px;
      }

      #message-input {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }

      #message-input input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
      }

      #message-input button {
        padding: 5px 10px;
      }
    </style>
  </head>

  <body>
    <h1>WebRTC Demo with Socket.io</h1>
    <div id="username-section">
      <label for="username">Enter your username:</label>
      <input type="text" id="username" />

      <label for="room-type">Choose Room Type:</label>
      <select id="room-type">
        <option value="friend-zone">Friend Zone</option>
        <option value="propagation">Propagation</option>
      </select>
      <label for="gender">Choose Your Gender:</label>
      <select id="gender">
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>

      <button id="start-button">Start</button>
      <div id="base-url" style="visibility: hidden"><%= LIVE_SERVER_URL %></div>
    </div>

    <div id="video-section" class="hidden">
      <h2>Video Call</h2>
      <div style="display: flex; gap: 0.5rem; justify-items: center">
        <div class="video-wrapper">
          <video id="local-video" autoplay muted playsinline></video>
          <div id="local-avatar" class="avatar hidden"></div>
        </div>
        <div class="video-wrapper">
          <video id="remote-video" autoplay playsinline></video>
          <div id="remote-avatar" class="avatar hidden"></div>
        </div>
      </div>
      <div id="controls" class="hidden">
        <button id="toggle-camera">Turn Off Camera</button>
        <button id="toggle-audio">Mute</button>
        <button id="share-screen">Share Screen</button>
        <button id="leave-room">Leave Room</button>
      </div>
      <div id="remote-status" class="hidden">
        <p>remote User:</p>
        <span id="remote-camera-status">Camera: On</span>
        <span id="remote-audio-status">Microphone: Unmuted</span>
      </div>
      <div id="connection-status" style="margin-top: 20px; font-weight: bold">
        Status: <span id="status-text">Waiting for user to join...</span>
      </div>
      <div style="display: flex; gap: 1rem">
        <div id="log" style="flex: 1"></div>
        <div style="flex: 1">
          <h3>Chat</h3>
          <div id="messages"></div>
        </div>
      </div>
      <div id="message-input">
        <input
          type="text"
          id="message-text"
          placeholder="Type your message..."
        />
        <button id="send-message">Send</button>
      </div>
    </div>

    <script>
      const LIVE_SERVER_URL = document.getElementById("base-url").innerText;
      const usernameInput = document.getElementById("username");
      const roomTypeInput = document.getElementById("room-type");
      const genderInput = document.getElementById("gender");
      const startButton = document.getElementById("start-button");
      const usernameSection = document.getElementById("username-section");
      const videoSection = document.getElementById("video-section");
      const statusText = document.getElementById("status-text");
      const localVideo = document.getElementById("local-video");
      const remoteVideo = document.getElementById("remote-video");
      const localAvatar = document.getElementById("local-avatar");
      const remoteAvatar = document.getElementById("remote-avatar");
      const logContainer = document.getElementById("log");
      const toggleCameraButton = document.getElementById("toggle-camera");
      const toggleAudioButton = document.getElementById("toggle-audio");
      const messagesContainer = document.getElementById("messages");
      const messageInput = document.getElementById("message-text");
      const sendMessageButton = document.getElementById("send-message");
      const remoteCameraStatus = document.getElementById(
        "remote-camera-status",
      );
      const remoteAudioStatus = document.getElementById("remote-audio-status");
      const shareScreenButton = document.getElementById("share-screen");
      const leaveRoomButton = document.getElementById("leave-room");

      let isScreenSharing = false;
      let screenStream;
      /**
       * @type {MediaStreamConstraints}
       */
      const mediaConstraints = {
        video: {
          width: { ideal: 320 },
          height: { ideal: 240 },
          frameRate: { ideal: 15 },
          facingMode: { ideal: "user" },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
      };
      let socket;
      let peerConnection;
      let localStream;
      let rtcConfig = {};
      let participants = [];
      const user = {
        id: new Date().getTime(),
        gender: "",
        username: "",
        isMobile: true,
        roomType: "",
      };

      // Track if we've already set up the remote video to avoid duplicate setup
      let remoteVideoSetup = false;
      let remoteStream = null;

      // Define STUN and TURN servers for better connectivity
      const iceServers = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          // Add free TURN servers
          {
            urls: "turn:numb.viagenie.ca",
            credential: "muazkh",
            username: "webrtc@live.com",
          },
        ],
      };

      // Mobile detection
      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent,
        );
      log("Device type: " + (isMobile ? "Mobile" : "Desktop"));

      // Function to handle screen sharing
      async function toggleScreenShare() {
        if (!isScreenSharing) {
          try {
            // Start screen sharing
            screenStream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
            });

            // Replace the current video track with the screen track
            const screenTrack = screenStream.getVideoTracks()[0];
            const sender = peerConnection
              .getSenders()
              .find((s) => s.track.kind === "video");
            if (sender) sender.replaceTrack(screenTrack);

            // Update the local video element
            localVideo.srcObject = screenStream;

            screenTrack.onended = () => {
              // Automatically stop screen sharing when the user stops sharing
              stopScreenShare();
            };

            isScreenSharing = true;
            shareScreenButton.textContent = "Stop Sharing";
          } catch (error) {
            log("Screen sharing failed: " + error.message);
          }
        } else {
          stopScreenShare();
        }
      }

      // Function to stop screen sharing
      function stopScreenShare() {
        if (screenStream) {
          const screenTrack = screenStream.getVideoTracks()[0];
          if (screenTrack) screenTrack.stop();

          // Revert to the original camera video track
          const videoTrack = localStream.getVideoTracks()[0];
          const sender = peerConnection
            .getSenders()
            .find((s) => s.track.kind === "video");
          if (sender) sender.replaceTrack(videoTrack);

          localVideo.srcObject = localStream;
          isScreenSharing = false;
          shareScreenButton.textContent = "Share Screen";
        }
      }

      // Add an event listener for the "Share Screen" button
      shareScreenButton.addEventListener("click", toggleScreenShare);

      leaveRoomButton.addEventListener("click", () => {
        socket?.emit("room:leave");
        if (peerConnection) peerConnection.close();
        peerConnection = null;
        log("left the room.");
        updateConnectionStatus("Waiting for user to join...");
        setInitials(remoteAvatar, "");
        document.getElementById("remote-status").classList.add("hidden");
        remoteVideo.srcObject = null;
        remoteVideoSetup = false; // Reset the flag
        remoteStream = null;

        // Remove any play buttons
        const playButton = document.querySelector(".manual-play-button");
        if (playButton) playButton.remove();

        rtcConfig = {};
        participants = [];
      });

      function updateConnectionStatus(status) {
        statusText.textContent = status;
      }

      function log(message) {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.textContent = message;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function setInitials(element, name) {
        const initials = name
          .split(" ")
          .map((n) => n[0])
          .join("")
          .toUpperCase();
        element.textContent = initials;
      }

      // Modify the getUserMedia function for mobile compatibility
      async function getUserMedia() {
        try {
          log("Accessing local media...");

          // Different constraints for mobile vs desktop
          const constraints = isMobile
            ? {
                video: {
                  width: { ideal: 320 },
                  height: { ideal: 240 },
                  frameRate: { max: 15 },
                },
                audio: true,
              }
            : {
                video: true,
                audio: true,
              };

          log("Using constraints: " + JSON.stringify(constraints));
          localStream = await navigator.mediaDevices.getUserMedia(constraints);

          // Set up local video
          localVideo.srcObject = localStream;
          localVideo.muted = true; // Mute local video to prevent feedback
          localVideo.playsInline = true; // Important for iOS

          try {
            await localVideo.play();
            log("Local video playback started");
          } catch (err) {
            log(`Error starting local video playback: ${err.message}`);
            // Try again with user interaction
            document.addEventListener(
              "click",
              () => {
                localVideo
                  .play()
                  .catch((e) =>
                    log("Still can't play local video: " + e.message),
                  );
              },
              { once: true },
            );
          }

          log(
            "Local media stream added with " +
              localStream.getTracks().length +
              " tracks",
          );
          localStream.getTracks().forEach((track) => {
            log(
              `Local ${track.kind} track added: enabled=${track.enabled}, muted=${track.muted}`,
            );
          });
        } catch (error) {
          log("Error getting User Media: " + error.message);
          alert(
            "Failed to access camera and microphone. Please ensure permissions are granted.",
          );
        }
      }

      async function initializeWebRTC() {
        try {
          updateConnectionStatus("Connecting to the other user...");
          log("Creating RTCPeerConnection...");

          // Use our predefined ice servers
          const config = {
            iceServers: iceServers.iceServers,
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
          };

          log("Using RTCPeerConnection config: " + JSON.stringify(config));
          peerConnection = new RTCPeerConnection(config);

          // Log all connection state changes
          peerConnection.onconnectionstatechange = () => {
            log("Connection state changed: " + peerConnection.connectionState);
            if (peerConnection.connectionState === "connected") {
              updateConnectionStatus("Connected");
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            log(
              "ICE connection state changed: " +
                peerConnection.iceConnectionState,
            );
            if (peerConnection.iceConnectionState === "disconnected") {
              log("ICE Disconnected. Attempting to reconnect...");
              if (peerConnection.restartIce) {
                peerConnection.restartIce();
              }
            }
          };

          peerConnection.onicegatheringstatechange = () => {
            log(
              "ICE gathering state changed: " +
                peerConnection.iceGatheringState,
            );
          };

          peerConnection.onsignalingstatechange = () => {
            log("Signaling state changed: " + peerConnection.signalingState);
          };

          // Add local tracks to the connection
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              log("Adding local track to peer connection: " + track.kind);
              peerConnection.addTrack(track, localStream);
            });
          } else {
            log("No local stream available to add tracks");
          }

          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              log("Sending ICE candidate...");
              socket.emit("rtc:candidate", { candidate: event.candidate });
            }
          };

          // Handle incoming tracks
          peerConnection.ontrack = (event) => {
            log("Track received: " + event.track.kind);

            if (event.streams && event.streams[0]) {
              log(
                "Remote stream received with " +
                  event.streams[0].getTracks().length +
                  " tracks",
              );

              // Store the remote stream
              remoteStream = event.streams[0];

              // Log all tracks in the remote stream
              remoteStream.getTracks().forEach((track) => {
                log(
                  `Remote ${track.kind} track: enabled=${track.enabled}, muted=${track.muted}`,
                );
              });

              // Set up the remote video
              setupRemoteVideo(remoteStream);
            } else {
              log("No remote stream available in the track event");
            }
          };

          log("WebRTC initialized with ICE servers.");
        } catch (error) {
          log("Error initializing WebRTC: " + error.message);
          updateConnectionStatus("Error connecting");
        }
      }

      // Function to set up the remote video
      function setupRemoteVideo(stream) {
        log(
          "Setting up remote video with stream that has " +
            stream.getTracks().length +
            " tracks",
        );

        // Check if video tracks exist
        const videoTracks = stream.getVideoTracks();
        if (videoTracks.length === 0) {
          log("WARNING: No video tracks in remote stream!");
        } else {
          log("Remote stream has " + videoTracks.length + " video tracks");
          videoTracks.forEach((track) => {
            log("Video track settings: " + JSON.stringify(track.getSettings()));
            log("Video track enabled: " + track.enabled);
            log("Video track muted: " + track.muted);

            // Ensure track is enabled
            track.enabled = true;
          });
        }

        // Set the source directly on the existing video element
        remoteVideo.srcObject = stream;
        remoteVideo.playsInline = true; // Important for iOS
        remoteVideo.muted = false;

        // Make sure remote video is visible
        remoteVideo.style.display = "block";
        remoteVideo.style.backgroundColor = "#000";

        document.getElementById("remote-status").classList.remove("hidden");

        // Create a play button for mobile devices
        createPlayButton();

        // Try to play the video automatically
        playRemoteVideo();

        // Add event listeners to monitor video state
        remoteVideo.addEventListener("loadedmetadata", () => {
          log("Remote video metadata loaded");
          setTimeout(playRemoteVideo, 500);
        });

        remoteVideo.addEventListener("playing", () => {
          log("Remote video is playing");
          const playButton = document.querySelector(".manual-play-button");
          if (playButton) playButton.style.display = "none";
        });
      }

      // Function to safely play the remote video
      function playRemoteVideo() {
        if (remoteVideo && remoteVideo.paused && remoteVideo.srcObject) {
          log("Attempting to play remote video...");

          // Ensure it's not muted
          remoteVideo.muted = false;

          // Try to play
          remoteVideo
            .play()
            .then(() => {
              log("Remote video is now playing");
            })
            .catch((err) => {
              log("Error playing remote video: " + err.message);
              // Make the play button visible
              const existingButton = document.querySelector(
                ".manual-play-button",
              );
              if (existingButton) {
                existingButton.style.display = "block";
              } else {
                createPlayButton();
              }
            });
        }
      }

      // Add a button to manually play the video
      function createPlayButton() {
        // Remove any existing buttons first
        const existingButton = document.querySelector(".manual-play-button");
        if (existingButton) existingButton.remove();

        const playButton = document.createElement("button");
        playButton.textContent = "Tap to Play Video";
        playButton.className = "manual-play-button";
        playButton.style.position = "absolute";
        playButton.style.top = "50%";
        playButton.style.left = "50%";
        playButton.style.transform = "translate(-50%, -50%)";
        playButton.style.zIndex = "10";
        playButton.style.padding = "10px 20px";
        playButton.style.backgroundColor = "#4CAF50";
        playButton.style.color = "white";
        playButton.style.border = "none";
        playButton.style.borderRadius = "5px";
        playButton.style.cursor = "pointer";

        playButton.onclick = () => {
          playRemoteVideo();
        };

        const remoteVideoWrapper =
          document.querySelector("#remote-video").parentElement;
        if (remoteVideoWrapper) {
          remoteVideoWrapper.appendChild(playButton);
        }
      }

      function updateStatus() {
        const videoTrack = localStream?.getVideoTracks()[0];
        const audioTrack = localStream?.getAudioTracks()[0];

        const status = {
          cameraOn: videoTrack?.enabled ?? false,
          audioOn: audioTrack?.enabled ?? false,
        };

        socket.emit("status:update", status);
      }

      startButton.addEventListener("click", async () => {
        const username = usernameInput.value.trim();
        const roomType = roomTypeInput.value;
        const gender = genderInput.value;

        if (!username) {
          alert("Username is required!");
          return;
        }
        if (!roomType) {
          alert("roomType is required!");
          return;
        }
        if (!gender) {
          alert("gender is required!");
          return;
        }
        user.username = username;
        user.roomType = roomType;
        user.gender = gender;

        usernameSection.classList.add("hidden");
        videoSection.classList.remove("hidden");
        document.getElementById("controls").classList.remove("hidden");

        setInitials(localAvatar, username);
        await getUserMedia();

        log(`Hello, ${username}! Connecting to server...`);
        updateConnectionStatus("Waiting for user to join...");

        socket = io(LIVE_SERVER_URL, { query: user });

        socket.on("connect", () => {
          log("Connected to the server.");
          socket.emit("room:join", { roomType });
        });

        socket.on("user:left", () => {
          log("remote user left");
          updateConnectionStatus("Waiting for user to join...");
          setInitials(remoteAvatar, "");
          remoteVideo.srcObject = null;
          remoteVideoSetup = false; // Reset the flag
          remoteStream = null;
          document.getElementById("remote-status").classList.add("hidden");

          // Remove any play buttons
          const playButton = document.querySelector(".manual-play-button");
          if (playButton) playButton.remove();
        });

        socket.on("room:start_offerer", async (config) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          log("Creating RTC offer...");
          const offer = await peerConnection.createOffer({
            iceRestart: true,
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          await peerConnection.setLocalDescription(offer);
          socket.emit("rtc:offer", { offer });
          log("RTC offer sent.");
        });

        socket.on("room:start", async (config) => {
          rtcConfig = config;
          await initializeWebRTC();
        });
        socket.on(
          "user:joined",
          ({
            socketId,
            username,
            gender,
            roomId,
            participants: newParticipants,
          }) => {
            participants = newParticipants;
            const remoteUser = participants.find(
              (_user) => _user.id !== user.id,
            );
            if (remoteUser?.username) {
              setInitials(remoteAvatar, remoteUser.username);
            }
          },
        );

        socket.on("rtc:offer", async ({ offer }) => {
          log("Received RTC offer");
          if (!peerConnection) {
            await initializeWebRTC();
          }

          try {
            log("Setting remote description from offer");
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(offer),
            );
            log("Set remote description from offer");

            log("Creating answer");
            const answer = await peerConnection.createAnswer();
            log("Created answer");

            log("Setting local description");
            await peerConnection.setLocalDescription(answer);
            log("Set local description");

            socket.emit("rtc:answer", { answer });
            log("Sent answer to peer");
          } catch (error) {
            log("Error handling offer: " + error.message);
          }
        });

        socket.on("rtc:answer", async ({ answer }) => {
          log("Received RTC answer");
          if (peerConnection) {
            try {
              log("Setting remote description from answer");
              await peerConnection.setRemoteDescription(
                new RTCSessionDescription(answer),
              );
              log("Set remote description from answer");
            } catch (error) {
              log("Error setting remote description: " + error.message);
            }
          }
        });

        socket.on("rtc:candidate", async ({ candidate }) => {
          log("Received ICE candidate");
          if (peerConnection) {
            try {
              log("Adding ICE candidate");
              await peerConnection.addIceCandidate(
                new RTCIceCandidate(candidate),
              );
              log("Added ICE candidate");
            } catch (error) {
              log("Error adding ICE candidate: " + error.message);
            }
          }
        });

        socket.on("status:update", ({ userId, roomUsers }) => {
          participants = roomUsers;
          const remoteUser = roomUsers.find((user) => user.id === userId);
          if (!remoteUser) {
            log("Remote User Not Found");
            return;
          }
          log(
            `Camera On: ${remoteUser.cameraOn}, Audio On: ${remoteUser.audioOn}`,
          );
          remoteCameraStatus.textContent = `Camera: ${
            remoteUser.cameraOn ? "On" : "Off"
          }`;

          remoteAudioStatus.textContent = `Microphone: ${
            remoteUser.audioOn ? "Unmuted" : "Muted"
          }`;

          if (!remoteUser.cameraOn) {
            remoteVideo.style.opacity = "0.5";
          } else {
            remoteVideo.style.opacity = "1";
          }

          setInitials(remoteAvatar, remoteUser.username);
        });

        socket.on("message:receive", (messages) => {
          messagesContainer.innerHTML = "";
          messages.forEach((message) => {
            const { username, value } = message;
            appendMessage(username, value);
          });
        });

        socket.on("disconnect", () => {
          log("Disconnected from the server.");
          if (peerConnection) peerConnection.close();
          peerConnection = null;
        });

        // Add document-level event listeners for mobile devices
        document.addEventListener("DOMContentLoaded", () => {
          // Add event listeners to handle autoplay restrictions
          document.addEventListener("click", function () {
            if (remoteVideo && remoteVideo.paused && remoteVideo.srcObject) {
              playRemoteVideo();
            }
          });

          document.addEventListener("touchstart", function () {
            if (remoteVideo && remoteVideo.paused && remoteVideo.srcObject) {
              playRemoteVideo();
            }
          });
        });
      });

      function appendMessage(username, message) {
        const messageEntry = document.createElement("div");
        messageEntry.innerHTML = `<strong>${username}:</strong> ${message}`;
        messagesContainer.appendChild(messageEntry);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      toggleCameraButton.addEventListener("click", () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            toggleCameraButton.textContent = videoTrack.enabled
              ? "Turn Off Camera"
              : "Turn On Camera";
          }
        }
        updateStatus();
      });

      toggleAudioButton.addEventListener("click", () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            toggleAudioButton.textContent = audioTrack.enabled
              ? "Mute"
              : "Unmute";
          }
        }
        updateStatus();
      });

      sendMessageButton.addEventListener("click", () => {
        const message = messageInput.value.trim();
        if (message) {
          socket.emit("message:send", { message });
          messageInput.value = "";
        }
      });

      messageInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") sendMessageButton.click();
      });
    </script>
  </body>
</html>
