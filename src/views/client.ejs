<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Demo</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }

      #log {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f9f9f9;
        margin-top: 20px;
      }

      #messages {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f1f1f1;
        margin-top: 20px;
      }

      .hidden {
        display: none;
      }

      .log-entry {
        margin-bottom: 10px;
      }

      video {
        width: 300px;
        height: 200px;
        border: 1px solid #ccc;
        background: #000;
      }

      .avatar {
        width: 20px;
        height: 20px;
        background: #8b430b;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        font-weight: bold;
        text-transform: uppercase;
        position: absolute;
        bottom: 0;
        left: 0;
        border-radius: 9999px;
      }

      .video-wrapper {
        position: relative;
        display: inline-block;
      }

      #controls button {
        margin: 5px;
      }

      #message-input {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }

      #message-input input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
      }

      #message-input button {
        padding: 5px 10px;
      }
    </style>
  </head>

  <body>
    <h1>WebRTC Demo with Socket.io</h1>
    <div id="username-section">
      <label for="username">Enter your username:</label>
      <input type="text" id="username" />

      <label for="room-type">Choose Room Type:</label>
      <select id="room-type">
        <option value="friend-zone">Friend Zone</option>
        <option value="propagation">Propagation</option>
      </select>
      <label for="gender">Choose Your Gender:</label>
      <select id="gender">
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>

      <button id="start-button">Start</button>
      <div id="base-url" style="visibility: hidden"><%= LIVE_SERVER_URL %></div>
    </div>

    <div id="video-section" class="hidden">
      <h2>Video Call</h2>
      <div style="display: flex; gap: 0.5rem; justify-items: center">
        <div class="video-wrapper">
          <video id="local-video" autoplay muted playsinline></video>
          <div id="local-avatar" class="avatar hidden"></div>
        </div>
        <div class="video-wrapper">
          <video id="remote-video" autoplay playsinline></video>
          <div id="remote-avatar" class="avatar hidden"></div>
        </div>
      </div>
      <div id="controls" class="hidden">
        <button id="toggle-camera">Turn Off Camera</button>
        <button id="toggle-audio">Mute</button>
        <button id="share-screen">Share Screen</button>
        <button id="leave-room">Leave Room</button>
      </div>
      <div id="remote-status" class="hidden">
        <p>remote User:</p>
        <span id="remote-camera-status">Camera: On</span>
        <span id="remote-audio-status">Microphone: Unmuted</span>
      </div>
      <div id="connection-status" style="margin-top: 20px; font-weight: bold">
        Status: <span id="status-text">Waiting for user to join...</span>
      </div>
      <div style="display: flex; gap: 1rem">
        <div id="log" style="flex: 1"></div>
        <div style="flex: 1">
          <h3>Chat</h3>
          <div id="messages"></div>
        </div>
      </div>
      <div id="message-input">
        <input
          type="text"
          id="message-text"
          placeholder="Type your message..."
        />
        <button id="send-message">Send</button>
      </div>
    </div>

    <script>
      const LIVE_SERVER_URL = document.getElementById("base-url").innerText;
      const usernameInput = document.getElementById("username");
      const roomTypeInput = document.getElementById("room-type");
      const genderInput = document.getElementById("gender");
      const startButton = document.getElementById("start-button");
      const usernameSection = document.getElementById("username-section");
      const videoSection = document.getElementById("video-section");
      const statusText = document.getElementById("status-text");
      const localVideo = document.getElementById("local-video");
      const remoteVideo = document.getElementById("remote-video");
      const localAvatar = document.getElementById("local-avatar");
      const remoteAvatar = document.getElementById("remote-avatar");
      const logContainer = document.getElementById("log");
      const toggleCameraButton = document.getElementById("toggle-camera");
      const toggleAudioButton = document.getElementById("toggle-audio");
      const messagesContainer = document.getElementById("messages");
      const messageInput = document.getElementById("message-text");
      const sendMessageButton = document.getElementById("send-message");
      const remoteCameraStatus = document.getElementById(
        "remote-camera-status",
      );
      const remoteAudioStatus = document.getElementById("remote-audio-status");
      const shareScreenButton = document.getElementById("share-screen");
      const leaveRoomButton = document.getElementById("leave-room");

      let isScreenSharing = false;
      let screenStream;
      /**
       * @type {MediaStreamConstraints}
       */
      const mediaConstraints = {
        video: true,
        audio: true,
      };

      let socket;
      let peerConnection;
      let localStream;
      let rtcConfig = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
          {
            urls: "turn:global.turn.twilio.com:3478?transport=udp",
            username:
              "f4b4035eaa76f77e3b3f90eda80ce6daa4d9c7dfa3d97745a089b4ec",
            credential: "dECYpK/WYXVxGFHK8uEXza7hRMmXmLKI9JjvtG4nF9Y=",
          },
        ],
        iceCandidatePoolSize: 10,
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        iceTransportPolicy: "all",
      };

      let participants = [];
      const user = {
        id: new Date().getTime(),
        gender: "",
        username: "",
        isMobile: true,
        roomType: "",
      };

      // Function to handle screen sharing
      async function toggleScreenShare() {
        if (!isScreenSharing) {
          try {
            screenStream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
            });
            const screenTrack = screenStream.getVideoTracks()[0];
            const sender = peerConnection
              .getSenders()
              .find((s) => s.track.kind === "video");
            if (sender) sender.replaceTrack(screenTrack);
            localVideo.srcObject = screenStream;
            isScreenSharing = true;
            console.log("Screen sharing started.");
          } catch (error) {
            console.error("Screen sharing failed:", error);
          }
        } else {
          stopScreenShare();
        }
      }

      // Function to stop screen sharing
      function stopScreenShare() {
        if (screenStream) {
          const screenTrack = screenStream.getVideoTracks()[0];
          if (screenTrack) screenTrack.stop();

          // Revert to the original camera video track
          const videoTrack = localStream.getVideoTracks()[0];
          const sender = peerConnection
            .getSenders()
            .find((s) => s.track.kind === "video");
          if (sender) sender.replaceTrack(videoTrack);

          localVideo.srcObject = localStream;
          isScreenSharing = false;
          shareScreenButton.textContent = "Share Screen";
        }
      }

      // Add an event listener for the "Share Screen" button
      shareScreenButton.addEventListener("click", toggleScreenShare);

      leaveRoomButton.addEventListener("click", () => {
        socket?.emit("room:leave");
        if (peerConnection) peerConnection.close();
        peerConnection = null;
        log("left the room.");
        updateConnectionStatus("Waiting for user to join...");
        setInitials(remoteAvatar, "");
        document.getElementById("remote-status").classList.add("hidden");
        remoteVideo.srcObject = undefined;

        rtcConfig = {};
        participants = [];
      });

      function updateConnectionStatus(status) {
        statusText.textContent = status;
      }

      function log(message) {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.textContent = message;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function setInitials(element, name) {
        const initials = name
          .split(" ")
          .map((n) => n[0])
          .join("")
          .toUpperCase();
        element.textContent = initials;
      }

      async function getUserMedia() {
        try {
          log("Accessing local media...");

          try {
            // First try with video and audio
            localStream = await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true,
            });
            log("Camera and microphone access successful");
          } catch (err) {
            log("Full media access failed: " + err.message);

            try {
              // Try with just audio if video fails
              localStream = await navigator.mediaDevices.getUserMedia({
                video: false,
                audio: true,
              });
              log("Audio-only access successful");
              localAvatar.classList.remove("hidden");
            } catch (audioErr) {
              log("Audio access also failed: " + audioErr.message);
              throw new Error("Could not access any media devices");
            }
          }

          if (localStream) {
            localVideo.srcObject = localStream;

            // Check if we have video tracks
            if (localStream.getVideoTracks().length > 0) {
              log(`Got video track: ${localStream.getVideoTracks()[0].label}`);
              localAvatar.classList.add("hidden");
            } else {
              log("No video tracks available");
              localAvatar.classList.remove("hidden");
            }

            // Try to play the video
            try {
              await localVideo.play();
            } catch (playErr) {
              log("Video play error: " + playErr.message);
              // Continue anyway as this might be an autoplay restriction
            }
          }

          updateStatus();
        } catch (error) {
          log("Media access completely failed: " + error.message);
          localAvatar.classList.remove("hidden");
          alert(
            "Camera access failed. Please check your permissions and try again.",
          );
        }
      }

      async function initializeWebRTC() {
        try {
          updateConnectionStatus("Connecting to the other user...");
          log("Creating RTCPeerConnection...");

          // Close any existing connection
          if (peerConnection) {
            peerConnection.close();
          }

          // Create new connection with our config
          peerConnection = new RTCPeerConnection(rtcConfig);

          peerConnection.onconnectionstatechange = () => {
            log(`Connection state changed: ${peerConnection.connectionState}`);
            if (peerConnection.connectionState === "connected") {
              updateConnectionStatus("Connected");
            } else if (peerConnection.connectionState === "failed") {
              log("Connection failed. Attempting to restart...");
              restartConnection();
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            log(`ICE connection state: ${peerConnection.iceConnectionState}`);
            if (
              peerConnection.iceConnectionState === "disconnected" ||
              peerConnection.iceConnectionState === "failed"
            ) {
              log("ICE connection issue. Attempting to restart...");
              restartConnection();
            }
          };

          // Add all tracks from local stream to peer connection
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              log(`Adding ${track.kind} track to peer connection`);
              peerConnection.addTrack(track, localStream);
            });
          } else {
            log("Warning: No local stream to add to peer connection");
          }

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              log(`ICE candidate generated`);
              socket.emit("rtc:candidate", { candidate: event.candidate });
            } else {
              log("ICE candidate gathering complete");
            }
          };

          peerConnection.ontrack = (event) => {
            log(`Remote track received: ${event.track.kind}`);

            if (event.streams && event.streams[0]) {
              remoteVideo.srcObject = event.streams[0];

              // Show remote avatar if no video tracks
              if (event.track.kind === "video") {
                remoteAvatar.classList.add("hidden");
                log("Remote video track connected");
              } else {
                log("Remote audio track connected");
              }

              document
                .getElementById("remote-status")
                .classList.remove("hidden");

              // Monitor remote track status
              event.track.onmute = () => {
                log(`Remote ${event.track.kind} muted`);
                if (event.track.kind === "video") {
                  remoteAvatar.classList.remove("hidden");
                }
              };

              event.track.onunmute = () => {
                log(`Remote ${event.track.kind} unmuted`);
                if (event.track.kind === "video") {
                  remoteAvatar.classList.add("hidden");
                }
              };

              event.track.onended = () => {
                log(`Remote ${event.track.kind} ended`);
                if (event.track.kind === "video") {
                  remoteAvatar.classList.remove("hidden");
                }
              };
            }
          };

          log("WebRTC initialized successfully.");
        } catch (error) {
          log("Error initializing WebRTC: " + error.message);
          updateConnectionStatus("Connection error. Please try again.");
        }
      }

      // Function to completely restart the connection
      async function restartConnection() {
        try {
          log("Restarting connection...");

          // Close existing connection
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
          }

          // Reinitialize WebRTC
          await initializeWebRTC();

          // Notify server to restart the connection process
          socket.emit("connection:restart");

          updateConnectionStatus("Reconnecting...");
        } catch (error) {
          log("Error during connection restart: " + error.message);
        }
      }

      // Simplified reconnect attempt
      function attemptReconnect() {
        log("Attempting to reconnect...");
        if (peerConnection && peerConnection.restartIce) {
          peerConnection.restartIce();
          log("ICE restart initiated");
        } else {
          restartConnection();
        }
      }

      startButton.addEventListener("click", async () => {
        const username = usernameInput.value.trim();
        const roomType = roomTypeInput.value;
        const gender = genderInput.value;

        if (!username) {
          alert("Username is required!");
          return;
        }
        if (!roomType) {
          alert("roomType is required!");
          return;
        }
        if (!gender) {
          alert("gender is required!");
          return;
        }
        user.username = username;
        user.roomType = roomType;
        user.gender = gender;

        usernameSection.classList.add("hidden");
        videoSection.classList.remove("hidden");
        document.getElementById("controls").classList.remove("hidden");

        setInitials(localAvatar, username);

        // Show loading indicator
        updateConnectionStatus("Initializing camera...");

        await getUserMedia();

        log(`Hello, ${username}! Connecting to server...`);
        updateConnectionStatus("Connecting to server...");

        socket = io(LIVE_SERVER_URL, {
          query: user,
          reconnectionAttempts: 5,
          reconnectionDelay: 1000,
          timeout: 20000,
        });

        socket.on("connect", () => {
          log("Connected to the server.");
          socket.emit("room:join", { roomType });
        });

        socket.on("connect_error", (error) => {
          log("Connection error: " + error.message);
          updateConnectionStatus("Server connection failed. Please try again.");
        });

        socket.on("reconnect", (attemptNumber) => {
          log(`Reconnected to server after ${attemptNumber} attempts`);
          socket.emit("room:join", { roomType });
        });

        // Add handler for connection restart request
        socket.on("connection:restart", async () => {
          log("Received restart request from server");
          await restartConnection();
        });

        socket.on("user:left", () => {
          log("remote user left");
          updateConnectionStatus("Waiting for user to join...");
          setInitials(remoteAvatar, "");
          remoteVideo.srcObject = undefined;
          document.getElementById("remote-status").classList.add("hidden");
        });

        socket.on("room:start_offerer", async (config) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          log("Creating RTC offer...");
          const offer = await peerConnection.createOffer({
            iceRestart: true,
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          await peerConnection.setLocalDescription(offer);
          socket.emit("rtc:offer", { offer });
          log("RTC offer sent.");
        });

        socket.on("room:start", async (config) => {
          rtcConfig = config;
          await initializeWebRTC();
        });
        socket.on(
          "user:joined",
          ({
            socketId,
            username,
            gender,
            roomId,
            participants: newParticipants,
          }) => {
            participants = newParticipants;
            const remoteUser = participants.find(
              (_user) => _user.id !== user.id,
            );
            if (remoteUser?.username) {
              setInitials(remoteAvatar, remoteUser.username);
            }
          },
        );

        socket.on("rtc:offer", async ({ offer }) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(offer),
          );

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.emit("rtc:answer", { answer });
        });

        socket.on("rtc:answer", async ({ answer }) => {
          if (peerConnection) {
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(answer),
            );
          }
        });

        socket.on("rtc:candidate", async ({ candidate }) => {
          if (peerConnection && peerConnection.remoteDescription) {
            try {
              log("Adding ICE candidate from remote peer");
              await peerConnection.addIceCandidate(
                new RTCIceCandidate(candidate),
              );
            } catch (err) {
              log("Error adding received ICE candidate: " + err.message);
            }
          } else {
            log("Received ICE candidate but peer connection not ready");
          }
        });

        socket.on("status:update", ({ userId, roomUsers }) => {
          participants = roomUsers;
          const remoteUser = roomUsers.find((user) => user.id === userId);
          if (!remoteUser) {
            log("Remote User Not Found");
            return;
          }
          log(
            `Camera On: ${remoteUser.cameraOn}, Audio On: ${remoteUser.audioOn}`,
          );
          remoteCameraStatus.textContent = `Camera: ${
            remoteUser.cameraOn ? "On" : "Off"
          }`;

          remoteAudioStatus.textContent = `Microphone: ${
            remoteUser.audioOn ? "Unmuted" : "Muted"
          }`;

          if (!remoteUser.cameraOn) {
            remoteVideo.style.opacity = "0.5";
          } else {
            remoteVideo.style.opacity = "1";
          }

          setInitials(remoteAvatar, remoteUser.username);
        });

        socket.on("message:receive", (messages) => {
          messagesContainer.innerHTML = "";
          messages.forEach((message) => {
            const { username, value } = message;
            appendMessage(username, value);
          });
        });

        socket.on("disconnect", () => {
          log("Disconnected from the server.");
          if (peerConnection) peerConnection.close();
          peerConnection = null;
        });
      });

      function appendMessage(username, message) {
        const messageEntry = document.createElement("div");
        messageEntry.innerHTML = `<strong>${username}:</strong> ${message}`;
        messagesContainer.appendChild(messageEntry);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      toggleCameraButton.addEventListener("click", () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            toggleCameraButton.textContent = videoTrack.enabled
              ? "Turn Off Camera"
              : "Turn On Camera";
          }
        }
        updateStatus();
      });

      toggleAudioButton.addEventListener("click", () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            toggleAudioButton.textContent = audioTrack.enabled
              ? "Mute"
              : "Unmute";
          }
        }
        updateStatus();
      });

      sendMessageButton.addEventListener("click", () => {
        const message = messageInput.value.trim();
        if (message) {
          socket.emit("message:send", { message });
          messageInput.value = "";
        }
      });

      messageInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") sendMessageButton.click();
      });

      function updateStatus() {
        const videoTrack = localStream?.getVideoTracks()[0];
        const audioTrack = localStream?.getAudioTracks()[0];

        const status = {
          cameraOn: videoTrack?.enabled ?? false,
          audioOn: audioTrack?.enabled ?? false,
        };

        socket.emit("status:update", status);
      }
    </script>
  </body>
</html>
