<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Demo</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }

      #log {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f9f9f9;
        margin-top: 20px;
      }

      #messages {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f1f1f1;
        margin-top: 20px;
      }

      .hidden {
        display: none;
      }

      .log-entry {
        margin-bottom: 10px;
      }

      video {
        width: 300px;
        height: 200px;
        border: 1px solid #ccc;
        background: #000;
      }

      .avatar {
        width: 20px;
        height: 20px;
        background: #8b430b;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        font-weight: bold;
        text-transform: uppercase;
        position: absolute;
        bottom: 0;
        left: 0;
        border-radius: 9999px;
      }

      .video-wrapper {
        position: relative;
        display: inline-block;
      }

      #controls button {
        margin: 5px;
      }

      #message-input {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }

      #message-input input {
        flex: 1;
        padding: 5px;
        border: 1px solid #ccc;
      }

      #message-input button {
        padding: 5px 10px;
      }
    </style>
  </head>

  <body>
    <h1>WebRTC Demo with Socket.io</h1>
    <div id="username-section">
      <label for="username">Enter your username:</label>
      <input type="text" id="username" />

      <label for="room-type">Choose Room Type:</label>
      <select id="room-type">
        <option value="friend-zone">Friend Zone</option>
        <option value="propagation">Propagation</option>
      </select>
      <label for="gender">Choose Your Gender:</label>
      <select id="gender">
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>

      <button id="start-button">Start</button>
      <div id="base-url" style="visibility: hidden"><%= LIVE_SERVER_URL %></div>
    </div>

    <div id="video-section" class="hidden">
      <h2>Video Call</h2>
      <div style="display: flex; gap: 0.5rem; justify-items: center">
        <div class="video-wrapper">
          <video id="local-video" autoplay muted playsinline></video>
          <div id="local-avatar" class="avatar hidden"></div>
        </div>
        <div class="video-wrapper">
          <video id="remote-video" autoplay playsinline></video>
          <div id="remote-avatar" class="avatar hidden"></div>
        </div>
      </div>
      <div id="controls" class="hidden">
        <button id="toggle-camera">Turn Off Camera</button>
        <button id="toggle-audio">Mute</button>
        <button id="share-screen">Share Screen</button>
        <button id="leave-room">Leave Room</button>
      </div>
      <div id="remote-status" class="hidden">
        <p>remote User:</p>
        <span id="remote-camera-status">Camera: On</span>
        <span id="remote-audio-status">Microphone: Unmuted</span>
      </div>
      <div id="connection-status" style="margin-top: 20px; font-weight: bold">
        Status: <span id="status-text">Waiting for user to join...</span>
      </div>
      <div style="display: flex; gap: 1rem">
        <div id="log" style="flex: 1"></div>
        <div style="flex: 1">
          <h3>Chat</h3>
          <div id="messages"></div>
        </div>
      </div>
      <div id="message-input">
        <input
          type="text"
          id="message-text"
          placeholder="Type your message..."
        />
        <button id="send-message">Send</button>
      </div>
    </div>

    <script>
      const LIVE_SERVER_URL = document.getElementById("base-url").innerText;
      const usernameInput = document.getElementById("username");
      const roomTypeInput = document.getElementById("room-type");
      const genderInput = document.getElementById("gender");
      const startButton = document.getElementById("start-button");
      const usernameSection = document.getElementById("username-section");
      const videoSection = document.getElementById("video-section");
      const statusText = document.getElementById("status-text");
      const localVideo = document.getElementById("local-video");
      const remoteVideo = document.getElementById("remote-video");
      const localAvatar = document.getElementById("local-avatar");
      const remoteAvatar = document.getElementById("remote-avatar");
      const logContainer = document.getElementById("log");
      const toggleCameraButton = document.getElementById("toggle-camera");
      const toggleAudioButton = document.getElementById("toggle-audio");
      const messagesContainer = document.getElementById("messages");
      const messageInput = document.getElementById("message-text");
      const sendMessageButton = document.getElementById("send-message");
      const remoteCameraStatus = document.getElementById(
        "remote-camera-status",
      );
      const remoteAudioStatus = document.getElementById("remote-audio-status");
      const shareScreenButton = document.getElementById("share-screen");
      const leaveRoomButton = document.getElementById("leave-room");

      let isScreenSharing = false;
      let screenStream;
      /**
       * @type {MediaStreamConstraints}
       */
      const mediaConstraints = {
        video: {
          width: { ideal: 640, max: 1280 },
          height: { ideal: 480, max: 720 },
          frameRate: { ideal: 24, max: 30 },
          facingMode: { ideal: "user" },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
      };

      let socket;
      let peerConnection;
      let localStream;
      let rtcConfig = {};
      let participants = [];
      const user = {
        id: new Date().getTime(),
        gender: "",
        username: "",
        isMobile: true,
        roomType: "",
      };

      // Function to handle screen sharing
      async function toggleScreenShare() {
        if (!isScreenSharing) {
          try {
            screenStream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
            });
            const screenTrack = screenStream.getVideoTracks()[0];
            const sender = peerConnection
              .getSenders()
              .find((s) => s.track.kind === "video");
            if (sender) sender.replaceTrack(screenTrack);
            localVideo.srcObject = screenStream;
            isScreenSharing = true;
            console.log("Screen sharing started.");
          } catch (error) {
            console.error("Screen sharing failed:", error);
          }
        } else {
          stopScreenShare();
        }
      }

      // Function to stop screen sharing
      function stopScreenShare() {
        if (screenStream) {
          const screenTrack = screenStream.getVideoTracks()[0];
          if (screenTrack) screenTrack.stop();

          // Revert to the original camera video track
          const videoTrack = localStream.getVideoTracks()[0];
          const sender = peerConnection
            .getSenders()
            .find((s) => s.track.kind === "video");
          if (sender) sender.replaceTrack(videoTrack);

          localVideo.srcObject = localStream;
          isScreenSharing = false;
          shareScreenButton.textContent = "Share Screen";
        }
      }

      // Add an event listener for the "Share Screen" button
      shareScreenButton.addEventListener("click", toggleScreenShare);

      leaveRoomButton.addEventListener("click", () => {
        socket?.emit("room:leave");
        if (peerConnection) peerConnection.close();
        peerConnection = null;
        log("left the room.");
        updateConnectionStatus("Waiting for user to join...");
        setInitials(remoteAvatar, "");
        document.getElementById("remote-status").classList.add("hidden");
        remoteVideo.srcObject = undefined;

        rtcConfig = {};
        participants = [];
      });

      function updateConnectionStatus(status) {
        statusText.textContent = status;
      }

      function log(message) {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.textContent = message;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function setInitials(element, name) {
        const initials = name
          .split(" ")
          .map((n) => n[0])
          .join("")
          .toUpperCase();
        element.textContent = initials;
      }

      async function getUserMedia() {
        try {
          log("Accessing local media...");

          // First try with ideal constraints
          try {
            localStream = await navigator.mediaDevices.getUserMedia(
              mediaConstraints,
            );
          } catch (initialError) {
            log("Initial media access failed, trying fallback options...");

            // Fallback to basic constraints if detailed ones fail
            localStream = await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true,
            });
          }

          localVideo.srcObject = localStream;

          // Use play() in a user interaction context to avoid autoplay restrictions
          try {
            await localVideo.play();
            log("Local media stream added successfully.");
          } catch (playError) {
            log(`Error starting local video playback: ${playError.message}`);
            // Show the avatar if video fails
            localAvatar.classList.remove("hidden");
          }

          // Update initial status after stream is acquired
          updateStatus();
        } catch (error) {
          log("Error getting User Media: " + error.message);
          // Show avatar as fallback
          localAvatar.classList.remove("hidden");
          alert(
            "Camera access failed. Please check your permissions and try again.",
          );
        }
      }

      async function initializeWebRTC() {
        try {
          updateConnectionStatus("Connecting to the other user...");
          log("Creating RTCPeerConnection...");

          // Get the config from server
          if (!rtcConfig || Object.keys(rtcConfig).length === 0) {
            log("Using default STUN/TURN configuration");
            rtcConfig = {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
              ],
            };
          }

          peerConnection = new RTCPeerConnection(rtcConfig);

          // Add connection state logging for debugging
          peerConnection.onconnectionstatechange = () => {
            log(`Connection state changed: ${peerConnection.connectionState}`);
            if (peerConnection.connectionState === "connected") {
              updateConnectionStatus("Connected");
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            log(`ICE connection state: ${peerConnection.iceConnectionState}`);
            if (peerConnection.iceConnectionState === "disconnected") {
              log("Disconnected. Attempting to reconnect...");
              attemptReconnect(peerConnection, rtcConfig);
            }
          };

          // Log ICE gathering state changes
          peerConnection.onicegatheringstatechange = () => {
            log(`ICE gathering state: ${peerConnection.iceGatheringState}`);
          };

          // Add all tracks from local stream to peer connection
          if (localStream) {
            localStream.getTracks().forEach((track) => {
              log(`Adding ${track.kind} track to peer connection`);
              peerConnection.addTrack(track, localStream);
            });
          } else {
            log("Warning: No local stream to add to peer connection");
          }

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              log(
                `Sending ICE candidate: ${event.candidate.candidate.substring(
                  0,
                  50,
                )}...`,
              );
              socket.emit("rtc:candidate", { candidate: event.candidate });
            }
          };

          peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
              log(`Received ${event.track.kind} track from remote peer`);
              remoteVideo.srcObject = event.streams[0];

              // Handle remote video element
              remoteVideo.onloadedmetadata = () => {
                log("Remote video metadata loaded");
                remoteVideo
                  .play()
                  .catch((e) => log(`Remote video play error: ${e.message}`));
              };

              document
                .getElementById("remote-status")
                .classList.remove("hidden");
            }
          };

          log("WebRTC initialized successfully.");
        } catch (error) {
          log("Error initializing WebRTC: " + error.message);
          updateConnectionStatus("Connection error. Please try again.");
        }
      }

      function updateStatus() {
        const videoTrack = localStream?.getVideoTracks()[0];
        const audioTrack = localStream?.getAudioTracks()[0];

        const status = {
          cameraOn: videoTrack?.enabled ?? false,
          audioOn: audioTrack?.enabled ?? false,
        };

        socket.emit("status:update", status);
      }

      function attemptReconnect() {
        if (peerConnection) {
          console.log("Restarting ICE...");
          peerConnection.restartIce();
        } else {
          console.log("Re-initializing WebRTC...");
          initializeWebRTC();
        }
      }

      startButton.addEventListener("click", async () => {
        const username = usernameInput.value.trim();
        const roomType = roomTypeInput.value;
        const gender = genderInput.value;

        if (!username) {
          alert("Username is required!");
          return;
        }
        if (!roomType) {
          alert("roomType is required!");
          return;
        }
        if (!gender) {
          alert("gender is required!");
          return;
        }
        user.username = username;
        user.roomType = roomType;
        user.gender = gender;

        usernameSection.classList.add("hidden");
        videoSection.classList.remove("hidden");
        document.getElementById("controls").classList.remove("hidden");

        setInitials(localAvatar, username);

        // Request permissions explicitly before getting user media
        try {
          // This will trigger the permission prompt
          await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          log("Permissions granted");
        } catch (permissionError) {
          log("Permission error: " + permissionError.message);
        }

        await getUserMedia();

        log(`Hello, ${username}! Connecting to server...`);
        updateConnectionStatus("Waiting for user to join...");

        socket = io(LIVE_SERVER_URL, { query: user });

        socket.on("connect", () => {
          log("Connected to the server.");
          socket.emit("room:join", { roomType });
        });

        socket.on("user:left", () => {
          log("remote user left");
          updateConnectionStatus("Waiting for user to join...");
          setInitials(remoteAvatar, "");
          remoteVideo.srcObject = undefined;
          document.getElementById("remote-status").classList.add("hidden");
        });

        socket.on("room:start_offerer", async (config) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          log("Creating RTC offer...");
          const offer = await peerConnection.createOffer({
            iceRestart: true,
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          await peerConnection.setLocalDescription(offer);
          socket.emit("rtc:offer", { offer });
          log("RTC offer sent.");
        });

        socket.on("room:start", async (config) => {
          rtcConfig = config;
          await initializeWebRTC();
        });
        socket.on(
          "user:joined",
          ({
            socketId,
            username,
            gender,
            roomId,
            participants: newParticipants,
          }) => {
            participants = newParticipants;
            const remoteUser = participants.find(
              (_user) => _user.id !== user.id,
            );
            if (remoteUser?.username) {
              setInitials(remoteAvatar, remoteUser.username);
            }
          },
        );

        socket.on("rtc:offer", async ({ offer }) => {
          if (!peerConnection) {
            await initializeWebRTC();
          }
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(offer),
          );

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.emit("rtc:answer", { answer });
        });

        socket.on("rtc:answer", async ({ answer }) => {
          if (peerConnection) {
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(answer),
            );
          }
        });

        socket.on("rtc:candidate", async ({ candidate }) => {
          if (peerConnection) {
            await peerConnection.addIceCandidate(
              new RTCIceCandidate(candidate),
            );
          }
        });

        socket.on("status:update", ({ userId, roomUsers }) => {
          participants = roomUsers;
          const remoteUser = roomUsers.find((user) => user.id === userId);
          if (!remoteUser) {
            log("Remote User Not Found");
            return;
          }
          log(
            `Camera On: ${remoteUser.cameraOn}, Audio On: ${remoteUser.audioOn}`,
          );
          remoteCameraStatus.textContent = `Camera: ${
            remoteUser.cameraOn ? "On" : "Off"
          }`;

          remoteAudioStatus.textContent = `Microphone: ${
            remoteUser.audioOn ? "Unmuted" : "Muted"
          }`;

          if (!remoteUser.cameraOn) {
            remoteVideo.style.opacity = "0.5";
          } else {
            remoteVideo.style.opacity = "1";
          }

          setInitials(remoteAvatar, remoteUser.username);
        });

        socket.on("message:receive", (messages) => {
          messagesContainer.innerHTML = "";
          messages.forEach((message) => {
            const { username, value } = message;
            appendMessage(username, value);
          });
        });

        socket.on("disconnect", () => {
          log("Disconnected from the server.");
          if (peerConnection) peerConnection.close();
          peerConnection = null;
        });
      });

      function appendMessage(username, message) {
        const messageEntry = document.createElement("div");
        messageEntry.innerHTML = `<strong>${username}:</strong> ${message}`;
        messagesContainer.appendChild(messageEntry);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      toggleCameraButton.addEventListener("click", () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            toggleCameraButton.textContent = videoTrack.enabled
              ? "Turn Off Camera"
              : "Turn On Camera";
          }
        }
        updateStatus();
      });

      toggleAudioButton.addEventListener("click", () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            toggleAudioButton.textContent = audioTrack.enabled
              ? "Mute"
              : "Unmute";
          }
        }
        updateStatus();
      });

      sendMessageButton.addEventListener("click", () => {
        const message = messageInput.value.trim();
        if (message) {
          socket.emit("message:send", { message });
          messageInput.value = "";
        }
      });

      messageInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") sendMessageButton.click();
      });
    </script>
  </body>
</html>
